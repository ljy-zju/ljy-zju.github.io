<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Junyuan's Homepage</title><meta name="author" content="Junyuan Lu(陆俊元)"><link rel="shortcut icon" href="/img/favicon_zju.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><header id="page_header"><div class="header_wrap"><div id="blog_name"><a class="blog_title" id="site-name" href="/">Junyuan's Homepage</a></div><button class="menus_icon"><div class="navicon"></div></button><ul class="menus_items"><li class="menus_item"><a class="site-page" href="/"> About</a></li><li class="menus_item"><a class="site-page" href="/Publications/"> Publications</a></li><li class="menus_item"><a class="site-page" href="/Projects/"> Projects</a></li><li class="menus_item"><a class="site-page" href="/Blogs/"> Blogs</a></li></ul><!-- Google tag (gtag.js)--><script type="text/javascript" async src="https://www.googletagmanager.com/gtag/js?id=G-VFQXJ5H7X2"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-VFQXJ5H7X2');</script></div></header><main id="page_main"><div class="side-card sticky"><div class="card-wrap" itemscope itemtype="http://schema.org/Person"><div class="author-avatar"><img class="avatar-img" src="/img/touxiang.JPG" onerror="this.onerror=null;this.src='/img/touxiang.JPG'" alt="avatar"></div><div class="author-discrip"><h3>Junyuan Lu(陆俊元)</h3><p class="author-bio">MPhil student at ZJU Intelligent Autonomous Systems Lab</p></div><div class="author-links"><button class="btn m-social-links">Links</button><ul class="social-links"><li><a class="e-social-link" href="https://scholar.google.com.hk/citations?user=-Vsr3WIAAAAJ&amp;hl=zh-CN" target="_blank"><i class="fas fa-graduation-cap" aria-hidden="true"></i><span>Google Scholar</span></a></li><li><a class="e-social-link" href="https://github.com/ljy-zju" target="_blank"><i class="fab fa-github-square" aria-hidden="true"></i><span>Github</span></a></li><li><a class="e-social-link" href="https://orcid.org/0000-0001-5559-2259" target="_blank"><i class="fab fa-orcid" aria-hidden="true"></i><span>ORCID</span></a></li><li><a class="e-social-link" href="mailto:[junyl@zju.edu.cn]" target="_blank"><i class="fas fa-envelope" aria-hidden="true"></i><span>E-mail</span></a></li><li><a class="e-social-link" href="javascript:void(0);" onclick="document.getElementById('wechatModal').style.display='block'"><i class="fab fa-weixin" aria-hidden="true"></i><span>WeChat</span></a><div class="modal" id="wechatModal"><div class="modal-content"></div><span class="close">&times;</span><img src="/img/wechatqrcode.jpg" alt="WeChat QR Code" style="width:100%"></div></li><li><a class="e-social-link" href="https://www.zhihu.com/people/lang-ji-lin-64" target="_blank"><i class="fab fa-zhihu" aria-hidden="true"></i><span>知乎主页</span></a></li></ul></div></div></div><div class="page" itemscope itemtype="http://schema.org/CreativeWork"><h2 class="page-title">代码随想录算法训练营第十天 | 232. 用栈实现队列、225. 用队列实现栈、20. 有效的括号、1047. 删除字符串中的所有相邻重复项</h2><article><hr>
<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a>232. 用栈实现队列</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html">click here</a></p>
</li>
<li><p>题目描述：使用栈实现队列的下列操作：</p>
<p>  push(x) – 将一个元素放入队列的尾部。<br>  pop() – 从队列首部移除元素。<br>  peek() – 返回队列首部的元素。<br>  empty() – 返回队列是否为空。</p>
</li>
<li><p>思路：<br>  关键在于栈的输出是与输入反序的，而涉及到反序的输出，昨天的字符串恰好有启发，double 反转，就变顺序了，这里也一样，拿另一个栈先接收输出序列，再从这个栈输出的时候就是和输入顺序一致的，也就模拟了队列的行为。</p>
<p>  进一步的，讲解中总结这种方法为输入、输出栈模式，并且有一个细节，就是每次调用pop或者peak接口的时候，如果输出栈内仍然有元素，那么就直接输出，因为里面就是最早输入“队列”的元素。而如果输出栈是空的，则本次需要先倒腾一手，把输入栈里的东西全都倒入输出栈。这样就确保了一般情况下，输入、输出都是O(1)复杂度，只有输出栈为空的时候，需要更大的开销。并且，由于所有的元素只会进、出输入输出栈各一次，所以总体复杂度还是O(n)。</p>
</li>
<li><p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; input_s;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; output_s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyQueue</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        input_s.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">peek</span>();</span><br><span class="line">        output_s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (output_s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!input_s.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                output_s.<span class="built_in">push</span>(input_s.<span class="built_in">top</span>());</span><br><span class="line">                input_s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output_s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> output_s.<span class="built_in">empty</span>() &amp;&amp; input_s.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>讲解代码中，实现了pop函数，然后peak调用pop，然后再把pop出来的元素塞回输出栈，按我的写法是可以避免的。</p>
</li>
<li><p>时空复杂度分析：<br>  O(n) 时间复杂度<br>  O(n) 空间复杂度</p>
</li>
</ul>
<hr>
<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a>225. 用队列实现栈</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/description/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html">click here</a></p>
</li>
<li><p>题目描述：使用队列实现栈的下列操作：</p>
<p>  push(x) – 元素 x 入栈<br>  pop() – 移除栈顶元素<br>  top() – 获取栈顶元素<br>  empty() – 返回栈是否为空</p>
</li>
<li><p>思路：<br>  这里感觉用两个队列来模拟栈的行为还比较奇怪，因为栈无法实现反序的效果。</p>
<p>  就用一个栈吧，只能手动操作了，结合昨天字符串左右旋的思路，如果我把队列前方的n-1个元素都旋转到最后方，此时队列最前方的元素，也就是最后输入的元素，就是最先输出的，模拟了栈的行为。</p>
<p>  细节是，这种旋转操作，如果不把最前方的元素pop出去，后续就很难维护整体的有序性了。所以这里代码要实现pop函数，然后top调用pop，并把pop出来的那个元素重新塞回队尾，也就是“栈顶”。</p>
<p>  感觉讲解里对top直接用队列的back其实是作弊了。</p>
</li>
<li><p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyStack</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; q.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> top = <span class="built_in">pop</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(top);</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时空复杂度分析：<br>  O(n) 时间复杂度<br>  O(n) 空间复杂度</p>
</li>
</ul>
<hr>
<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/description/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html">click here</a></p>
</li>
<li><p>题目描述：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>  有效字符串需满足：</p>
<p>  左括号必须用相同类型的右括号闭合。<br>  左括号必须以正确的顺序闭合。<br>  注意空字符串可被认为是有效字符串。</p>
</li>
<li><p>思路：<br>  字符串里只有括号类型，要判断字符串是否满足上述条件，一个个翻译即可：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合 + 左括号必须以正确的顺序闭合 &#x3D; 读取到右括号时，它之前一定是对应的左括号</li>
<li>注意空字符串可被认为是有效字符串 &#x3D; 特殊情况<br>  这种近邻相消的题目，适合用栈来做，因为每次相消后，栈顶元素就自动变为更旧的那个元素，用于与新来的元素进行比对。用讲解的话来说就是：<strong>括号匹配是使用栈解决的经典问题。</strong></li>
</ol>
<p>  具体的，从左往右读取字符串，左括号统统入栈，读取到右括号时，检测栈顶是否为对应的左括号，进而判断。</p>
</li>
<li><p>代码：写得非常直译思路</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sc;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sc.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!sc.<span class="built_in">empty</span>() &amp;&amp; sc.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sc.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!sc.<span class="built_in">empty</span>() &amp;&amp; sc.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sc.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!sc.<span class="built_in">empty</span>() &amp;&amp; sc.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sc.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sc.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时空复杂度分析：<br>  O(n) 时间复杂度<br>  O(n) 空间复杂度</p>
</li>
<li><p>讲解代码用到了技巧：<strong>在匹配左括号的时候，右括号先入栈，就只需要比较当前元素和栈顶相不相等就可以了</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果s的长度为奇数，一定不符合要求</span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>(); <span class="comment">// st.top() 与 s[i]相等，栈弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a>1047. 删除字符串中的所有相邻重复项</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html">click here</a></p>
</li>
<li><p>题目描述：给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>  在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>  在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
</li>
<li><p>思路：<br>  又是相邻匹配然后相消的，只不过上一题是左右括号要匹配，这道题直接是元素相等匹配。<br>  消除后，要将剩余的元素重新由栈转string，需要注意反序的特性。</p>
</li>
<li><p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sc;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sc.<span class="built_in">empty</span>() &amp;&amp; sc.<span class="built_in">top</span>() == c)</span><br><span class="line">            &#123;</span><br><span class="line">                sc.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                sc.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span>().<span class="built_in">swap</span>(s);</span><br><span class="line">        <span class="type">int</span> size = sc.<span class="built_in">size</span>();</span><br><span class="line">        s.<span class="built_in">resize</span>(size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = sc.<span class="built_in">top</span>();</span><br><span class="line">            sc.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时空复杂度分析：<br>  O(n) 时间复杂度<br>  O(n) 空间复杂度</p>
</li>
<li><p>讲解代码：进一步优化，直接以string模拟栈，进而避免由栈转字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result.<span class="built_in">empty</span>() || result.<span class="built_in">back</span>() != s) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时空复杂度分析：<br>  O(n) 时间复杂度<br>  O(1) 空间复杂度</p>
</li>
</ul>
<hr>
<h2 id="今日收获"><a href="#今日收获" class="headerlink" title="今日收获"></a>今日收获</h2><ul>
<li><p>个人博客更新。若Blog有误或是有其他想交流的，左侧有联系方式。</p>
</li>
<li><p>复习：<br>  今日核心思想：近邻匹配问题都是栈的强项</p>
<p>  <strong>用栈实现队列：</strong>模拟题，<strong>double反转后顺序不变</strong>的想法再次利用，输入输出栈模拟队列。<br>  <strong>用队列实现栈：</strong>模拟题，旋转换位思想，注意top后，为了维护顺序不变，需要将pop出来的元素重塞回队尾。<br>  <strong>有效的括号：</strong>近邻匹配，<strong>实现技巧上，通过将压入栈的内容取反，使得后续匹配到相反内容时，实际上是检测是否相等，这个想法后续可能会推广到更一般的function上。</strong><br>  <strong>删除字符串中的所有相邻重复项：</strong>近邻匹配，实现技巧上，直接<strong>用vector模拟栈</strong>，避免后续栈转vector的冗余操作。</p>
</li>
<li><p>耗时：2h</p>
</li>
</ul>
<hr>
<ul>
<li><a href="../../Blogs/day_nine">上一篇：代码随想录算法训练营第九天 | 151. 翻转字符串里的单词、卡码网：55.右旋转字符串、28. 实现 strStr()、459. 重复的子字符串</a></li>
<li><a href="../../Blogs/day_eleven">下一篇：代码随想录算法训练营第十一天 | 150. 逆波兰表达式求值、239. 滑动窗口最大值、347. 前 K 个高频元素</a></li>
</ul>
</article></div></main><div class="nav-wrap"><div class="nav"><button class="site-nav"><div class="navicon"></div></button><ul class="nav_items"><li class="nav_item"><a class="nav-page" href="/"> About</a></li><li class="nav_item"><a class="nav-page" href="/Publications/"> Publications</a></li><li class="nav_item"><a class="nav-page" href="/Projects/"> Projects</a></li><li class="nav_item"><a class="nav-page" href="/Blogs/"> Blogs</a></li></ul></div><div class="cd-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></div></div><footer id="page_footer"><div class="footer_wrap"><div class="copyright">&copy;2024 - 2025 by Junyuan Lu(陆俊元)</div><div class="theme-info">Powered by <a target="_blank" href="https://hexo.io" rel="nofollow noopener">Hexo</a> & <a target="_blank" href="https://github.com/PhosphorW/hexo-theme-academia" rel="nofollow noopener">Academia Theme</a></div><!-- 不蒜子统计--><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span></span><span class="post-meta-divider">|</span><span id="busuanzi_container_site_uv" style="display:none">本站访客数<span id="busuanzi_value_site_uv"></span></span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-pjax@latest/jquery.pjax.min.js"></script><script src="/js/main.js"></script><script src="//clustrmaps.com/map_v2.js?d=gO9Ee5geOQJr4A8o_oWFrvEhrFzUuwpnDv6pPrVbx8U&amp;cl=ffffff&amp;w=a"></script></body></html>