<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Junyuan's Homepage</title><meta name="author" content="Junyuan Lu(陆俊元)"><link rel="shortcut icon" href="/img/favicon_zju.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><header id="page_header"><div class="header_wrap"><div id="blog_name"><a class="blog_title" id="site-name" href="/">Junyuan's Homepage</a></div><button class="menus_icon"><div class="navicon"></div></button><ul class="menus_items"><li class="menus_item"><a class="site-page" href="/"> About</a></li><li class="menus_item"><a class="site-page" href="/Publications/"> Publications</a></li><li class="menus_item"><a class="site-page" href="/Projects/"> Projects</a></li><li class="menus_item"><a class="site-page" href="/Blogs/"> Blogs</a></li></ul><!-- Google tag (gtag.js)--><script type="text/javascript" async src="https://www.googletagmanager.com/gtag/js?id=G-VFQXJ5H7X2"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-VFQXJ5H7X2');</script></div></header><main id="page_main"><div class="side-card sticky"><div class="card-wrap" itemscope itemtype="http://schema.org/Person"><div class="author-avatar"><img class="avatar-img" src="/img/touxiang.JPG" onerror="this.onerror=null;this.src='/img/touxiang.JPG'" alt="avatar"></div><div class="author-discrip"><h3>Junyuan Lu(陆俊元)</h3><p class="author-bio">MPhil student at ZJU Intelligent Autonomous Systems Lab</p></div><div class="author-links"><button class="btn m-social-links">Links</button><ul class="social-links"><li><a class="e-social-link" href="https://scholar.google.com.hk/citations?user=-Vsr3WIAAAAJ&amp;hl=zh-CN" target="_blank"><i class="fas fa-graduation-cap" aria-hidden="true"></i><span>Google Scholar</span></a></li><li><a class="e-social-link" href="https://github.com/ljy-zju" target="_blank"><i class="fab fa-github-square" aria-hidden="true"></i><span>Github</span></a></li><li><a class="e-social-link" href="https://orcid.org/0000-0001-5559-2259" target="_blank"><i class="fab fa-orcid" aria-hidden="true"></i><span>ORCID</span></a></li><li><a class="e-social-link" href="mailto:[junyl@zju.edu.cn]" target="_blank"><i class="fas fa-envelope" aria-hidden="true"></i><span>E-mail</span></a></li><li><a class="e-social-link" href="javascript:void(0);" onclick="document.getElementById('wechatModal').style.display='block'"><i class="fab fa-weixin" aria-hidden="true"></i><span>WeChat</span></a><div class="modal" id="wechatModal"><div class="modal-content"></div><span class="close">&times;</span><img src="/img/wechatqrcode.jpg" alt="WeChat QR Code" style="width:100%"></div></li><li><a class="e-social-link" href="https://www.zhihu.com/people/lang-ji-lin-64" target="_blank"><i class="fab fa-zhihu" aria-hidden="true"></i><span>知乎主页</span></a></li></ul></div></div></div><div class="page" itemscope itemtype="http://schema.org/CreativeWork"><h2 class="page-title">代码随想录算法训练营第四天 | 24. 两两交换链表中的节点、19. 删除链表的倒数第N个节点、面试题 02.07. 链表相交、142. 环形链表II</h2><article><hr>
<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html">click here</a></p>
</li>
<li><p>题目描述：给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
</li>
<li><p>思路：<br>  这道题要求两两交换，所以如果如果节点数少于两个就直接退出<br>  交换的时候，要遵循昨天总结的“先记录，再修改”的原则，特别是为了能继续遍历链表，需要先记录好next，才能修改next。</p>
<p>  循环内部的具体的操作比较简单：拿到三个连续节点，last，<strong>cur</strong> 和 <strong>kid</strong>，<br>  交换：<strong>cur</strong> 和 <strong>kid</strong> 要交换，于此行为相配合的是这两个节点的前、后两个节点，即<br>  重指：last 的 next 要指向 kid，cur 的 next 则要指向 kid 的 下一个节点 kkid。<br>  位移：随后 last 指针向右移动两位，到 原 kid 现 cur 处，cur 指针顺延到 last 指针后一位处。<br>  循环上述交换、重指、位移操作即可。</p>
<p>  循环从哪里开始？<br>  用虚拟头节点 vhead ，减少不必要的特殊处理。<br>  所以可以从 last &#x3D; vhead 开始，这样就算一共只有两个节点，按上面的流程也是能满足要求的交换他们的位置。</p>
<p>  什么时候退出？<br>  单次交换完成后，last 依旧是有效的，所以需要看的是 cur 及其后一位，也就是下一次进行交换的两个节点是否都有效，只要有一个无效，就可以退出循环了。</p>
</li>
<li><p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">swapPairs</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !(head-&gt;next))</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *vhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode *last = vhead;</span><br><span class="line">        ListNode *cur = last-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; (cur-&gt;next))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> kid = cur-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> kkid = kid-&gt;next;</span><br><span class="line">            kid-&gt;next = cur;</span><br><span class="line">            cur-&gt;next = kkid;</span><br><span class="line">            last-&gt;next = kid;</span><br><span class="line"></span><br><span class="line">            last = cur;</span><br><span class="line">            cur = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>时空复杂度分析：<br>  完整遍历链表一次：O(n) 时间复杂度<br>  没有额外存储：O(1) 空间复杂度</p>
</li>
</ul>
<hr>
<h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html">click here</a></p>
</li>
<li><p>题目描述：给你一个链表，删除链表的倒数第 <strong>n</strong> 个结点，并且返回链表的头结点。<br>进阶：你能尝试使用一趟扫描实现吗？</p>
</li>
<li><p>思路：<br>  基础要求：<br>  先遍历整个链表，一共有多少个，然后看 倒数第 <strong>n</strong> 个 是 正数 第几个，再遍历到该位置进行删除即可。<br>  进阶要求：<br>  很奇怪啊很奇怪，我怎么能正好遍历到 倒数第 <strong>n</strong> 个 节点上？我似乎只能确保自己遍历到最后一个节点上了。<br>  这俩节点有什么关系呢？那就是俩节点之间的<strong>距离</strong>是确定的，定义为从一个节点到另一个节点要走多少步。<br>  显然，倒数第 <strong>n</strong> 个 节点与倒数第 <strong>1</strong> 个 节点之间的<strong>距离</strong>为 <strong>n-1</strong>。<br>  那么，当我遍历的时候，采用双指针法：<br>  让快指针先行 <strong>n-1</strong> 步，使得双指针的节点<strong>距离</strong>是 <strong>n-1</strong>，<br>  那么当快指针到最后一个节点的时候，慢指针正好走到要删除的那个节点上。<br><br>  实现中要注意，为了删一个节点，最好是拿到它的前一个节点，进行跳链接到它后一个节点来实现删除。<br>  所以快指针要先偷跑一步，好让慢指针届时指向要删除的节点的前一个节点。<br>  为了减少对头节点的特殊处理，采用虚拟头节点。</p>
</li>
<li><p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *vhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">auto</span> slow = vhead;</span><br><span class="line">        <span class="keyword">auto</span> fast = vhead-&gt;next; <span class="comment">// 偷跑一步</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next; <span class="comment">// 再跑n-1步</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next) <span class="comment">// 当快指针到达最后一个节点时，慢指针到了该删的节点的前一个。</span></span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> temp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next; <span class="comment">// 跳链接</span></span><br><span class="line">        <span class="keyword">delete</span> temp;                   <span class="comment">// 删除</span></span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> vhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html">click here</a></p>
</li>
<li><p>题目描述：简述为，两个单链表，找他们俩之间相交的部分的起点。</p>
</li>
<li><p>思路： </p>
<ul>
<li><p>我的想法：<br>  既然节点内有数据，且数据具有正数的特点，那么我先遍历A链表，把里面的数据全部改为负数。<br>  再遍历B链表，挨个检查里面的数据是不是负数，是则意味着这个节点在A中也存在，即为二者的交点。<br>  按照题目描述：不允许修改链表的结构，我并没有修改结构，只是修改了数据罢了。<br>  不过提交测试后发现链表的数据也不能修改，那么就在返回交点结果前，再遍历一次A，把内部的值都改为原值即可。</p>
</li>
<li><p>代码：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *vheadA = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, headA);</span><br><span class="line">        <span class="keyword">while</span> (headA)</span><br><span class="line">        &#123;</span><br><span class="line">            headA-&gt;val *= <span class="number">-1</span>;</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (headB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (headB-&gt;val &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                headA = vheadA-&gt;next;</span><br><span class="line">                <span class="keyword">while</span> (headA)</span><br><span class="line">                &#123;</span><br><span class="line">                    headA-&gt;val *= <span class="number">-1</span>;</span><br><span class="line">                    headA = headA-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                headB = headB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        headA = vheadA-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (headA)</span><br><span class="line">        &#123;</span><br><span class="line">            headA-&gt;val *= <span class="number">-1</span>;</span><br><span class="line">            headA = headA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>时间复杂度：O(2n+m)&#x3D;O(n+m)</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
<li><p>讲解中的思路：<br>  利用了一个链表相交的特点，那就是<strong>两个非循环链表如果相交，那么必然拥有相同的终点。</strong><br>  利用这一特点，就比较好检查两个链表有没有相交了，以及相交在何处了。<br>  如果两个链表一样长，那尾部本就是<strong>对齐</strong>的，直接以相等速度向后遍历，挨个比较当前节点的地址是否一样，是则相交。<br>  如果两个链表不一样长，根据上述特性，若他们相交，必然拥有相同的终点，<br>  于是乎<strong>先把尾部对齐</strong>，即让较长链表的迭代指针先走几步。<br>  然后再两个迭代指针一起向前走，并挨个比较当前节点的地址是否一样，是则相交。</p>
</li>
<li><p>时间复杂度：O(2n+2m)&#x3D;O(n+m)</p>
</li>
<li><p>空间复杂度：O(1)</p>
</li>
<li><p>我实现的代码：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *vheadA = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, headA);</span><br><span class="line">        ListNode *vheadB = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, headB);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> temp_a = vheadA-&gt;next;</span><br><span class="line">        <span class="type">int</span> size_a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp_a)</span><br><span class="line">        &#123;</span><br><span class="line">            size_a++;</span><br><span class="line">            temp_a = temp_a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> temp_b = vheadB-&gt;next;</span><br><span class="line">        <span class="type">int</span> size_b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp_b)</span><br><span class="line">        &#123;</span><br><span class="line">            size_b++;</span><br><span class="line">            temp_b = temp_b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp_a = vheadA-&gt;next;</span><br><span class="line">        temp_b = vheadB-&gt;next;</span><br><span class="line">        <span class="type">int</span> iter_size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (size_a &gt; size_b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> offset = size_a - size_b;</span><br><span class="line">            iter_size = size_b;</span><br><span class="line">            <span class="keyword">while</span> (offset--)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_a = temp_a-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (size_a &lt; size_b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> offset = size_b - size_a;</span><br><span class="line">            iter_size = size_a;</span><br><span class="line">            <span class="keyword">while</span> (offset--)</span><br><span class="line">            &#123;</span><br><span class="line">                temp_b = temp_b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            iter_size = size_a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iter_size--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp_a == temp_b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> temp_a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp_a = temp_a-&gt;next;</span><br><span class="line">                temp_b = temp_b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142. 环形链表II"></a>142. 环形链表II</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">click here</a></p>
</li>
<li><p>题目描述：给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>  如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>  不允许修改 链表。</p>
</li>
<li><p>思路：<br>  这个技巧性太强了，属于是<strong>必背题</strong>，之前刷过，所以依稀记得要快慢指针，快指针每次跳两格，慢指针每次跳一格。<br>  但是后续记得不太清楚了，于是又自己推理了一通：</p>
<p>  假设链表入环前的长度为 s ，环的长度为 c<br>  当慢指针走到入口处时，共 s 步，快指针已经走了 2s 步，在环前、环上分别走了 s 步<br>  很明显，快指针此时距离入口处的慢指针有 c - s 步距离（<strong>先假设环长 c 大于环前距离 s</strong>）。<br>  现在把二者在环内的运动视为追赶运动，也就是快指针每次比慢指针快一步，他俩之间的距离就缩小一步。<br>  c - s 步的距离需要 c - s 次运动。<br>  追赶上时，慢指针从入口处前向运动了 c - s 步，二者都停留在这个位置。</p>
<p>  下面的内容就是之前记不太清楚的后续：</p>
<p>  精髓的地方到了：<strong>此时二者再走 s 步就能回到环入口，s 正好也是从链表头到环入口的距离。</strong><br>  于是，把慢指针移动到链表头，快指针位置不变，二者都以单步1格的速度向前走<br>  当二者再次相遇时，就正好都处在环的入口处了。</p>
<p>  <strong>如果是环长 c 等于 环前距离 s 的时候</strong>，更简单了，二者第一次相遇就在入口处，所以上述方法也能处理。</p>
<p>  <strong>如果是环长 c 小于 环前距离 s 的时候</strong>，<br>  当慢指针走到入口处时，共 s 步，快指针已经走了 2s 步，在环前、环上分别走了 s 步<br>  那么快指针此时距离入口处有多远呢？<br>  首先看快指针超出入口处多远：s - c？应该是 s - n * c，这个 n 最小为 1。记为 y &#x3D; s - n * c &lt; c </p>
<p>  所以可知快指针此时距离入口处的慢指针为 c - y 步，不论这个值具体是多少，但它都小于 c。<br>  那么根据追赶运动每次会缩进快慢指针之间的距离一格，共需要 c - y 步，二者相遇。</p>
<p>  慢指针从入口处累计走了 c - y 步，所以二者相遇的位置也就是环上的 c - y 处</p>
<p>  此时把慢指针移动到链表头，让他再以单格的速度跳到环入口，需要 s 步<br>  快指针也以单格的速度，从刚刚双指针相遇的地方向前跳 s 步，将到达 c - y + s 处。<br>  c - y + s &#x3D; c - (s - n * c) + s &#x3D; (n * c + c)<br>  显然，由于 s &gt; c，所以需要用上面这个结果对 c 取模运算，才能得到最终快指针的位置：<br>  (n * c + c) % c &#x3D; 0，所以此时快指针也正好回到环入口了。</p>
<p>  综上，各种情况都能用上述算法处理。</p>
</li>
<li><p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> fast = head;</span><br><span class="line">        <span class="keyword">auto</span> slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span> (fast != slow)</span><br><span class="line">                &#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="今日收获"><a href="#今日收获" class="headerlink" title="今日收获"></a>今日收获</h2><ul>
<li><p>个人博客更新。若Blog有误或是有其他想交流的，左侧有联系方式。</p>
</li>
<li><p>复习：<br>  <strong>两两交换链表中的节点：</strong>模拟题，需要把握循环块内的操作：交换、重指、移动，以及循环退出条件：下一次操作的两个节点任一无效。<br>  <strong>删除链表的倒数第N个节点：</strong>根据确定性的能遍历到链表尾 + 待删除节点与链表尾的距离信息，用双指针控制相同的距离，来实现快指针到尾部时，慢指针指向待删除节点的<strong>前一个节点</strong>（快指针需要偷跑1格）。<br>  <strong>链表相交：</strong>利用相交链表尾部对齐的特性，先将长短链表变成尾部对齐，忽略长链表的前部分，再逐一比对地址即可确认是否相交。<br>  <strong>环形链表II：</strong>技巧题，直接记解法：快慢双指针，快的跳2格，慢的跳1格，相遇后慢指针移动到链表头，二者一起以1格速度移动，再次相遇处即为环形入口。</p>
</li>
<li><p>耗时：3h</p>
</li>
</ul>
<hr>
<ul>
<li><a href="../../Blogs/day_three">上一篇：代码随想录算法训练营第三天 | 203. 移除链表元素、707. 设计链表、206. 反转链表</a></li>
<li><a href="../../Blogs/day_six">下一篇：代码随想录算法训练营第六天 | 242. 有效的字母异位词、349. 两个数组的交集、202. 快乐数、1. 两数之和</a></li>
</ul>
</article></div></main><div class="nav-wrap"><div class="nav"><button class="site-nav"><div class="navicon"></div></button><ul class="nav_items"><li class="nav_item"><a class="nav-page" href="/"> About</a></li><li class="nav_item"><a class="nav-page" href="/Publications/"> Publications</a></li><li class="nav_item"><a class="nav-page" href="/Projects/"> Projects</a></li><li class="nav_item"><a class="nav-page" href="/Blogs/"> Blogs</a></li></ul></div><div class="cd-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></div></div><footer id="page_footer"><div class="footer_wrap"><div class="copyright">&copy;2024 - 2025 by Junyuan Lu(陆俊元)</div><div class="theme-info">Powered by <a target="_blank" href="https://hexo.io" rel="nofollow noopener">Hexo</a> & <a target="_blank" href="https://github.com/PhosphorW/hexo-theme-academia" rel="nofollow noopener">Academia Theme</a></div><!-- 不蒜子统计--><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span></span><span class="post-meta-divider">|</span><span id="busuanzi_container_site_uv" style="display:none">本站访客数<span id="busuanzi_value_site_uv"></span></span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-pjax@latest/jquery.pjax.min.js"></script><script src="/js/main.js"></script><script src="//clustrmaps.com/map_v2.js?d=gO9Ee5geOQJr4A8o_oWFrvEhrFzUuwpnDv6pPrVbx8U&amp;cl=ffffff&amp;w=a"></script></body></html>