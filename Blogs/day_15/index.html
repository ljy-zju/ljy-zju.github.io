<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Junyuan's Homepage</title><meta name="author" content="Junyuan Lu(陆俊元)"><link rel="shortcut icon" href="/img/favicon_zju.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><header id="page_header"><div class="header_wrap"><div id="blog_name"><a class="blog_title" id="site-name" href="/">Junyuan's Homepage</a></div><button class="menus_icon"><div class="navicon"></div></button><ul class="menus_items"><li class="menus_item"><a class="site-page" href="/"> About</a></li><li class="menus_item"><a class="site-page" href="/Publications/"> Publications</a></li><li class="menus_item"><a class="site-page" href="/Projects/"> Projects</a></li><li class="menus_item"><a class="site-page" href="/Blogs/"> Blogs</a></li></ul><!-- Google tag (gtag.js)--><script type="text/javascript" async src="https://www.googletagmanager.com/gtag/js?id=G-VFQXJ5H7X2"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-VFQXJ5H7X2');</script></div></header><main id="page_main"><div class="side-card sticky"><div class="card-wrap" itemscope itemtype="http://schema.org/Person"><div class="author-avatar"><img class="avatar-img" src="/img/touxiang.JPG" onerror="this.onerror=null;this.src='/img/touxiang.JPG'" alt="avatar"></div><div class="author-discrip"><h3>Junyuan Lu(陆俊元)</h3><p class="author-bio">MPhil student at ZJU Intelligent Autonomous Systems Lab</p></div><div class="author-links"><button class="btn m-social-links">Links</button><ul class="social-links"><li><a class="e-social-link" href="https://scholar.google.com.hk/citations?user=-Vsr3WIAAAAJ&amp;hl=zh-CN" target="_blank"><i class="fas fa-graduation-cap" aria-hidden="true"></i><span>Google Scholar</span></a></li><li><a class="e-social-link" href="https://github.com/ljy-zju" target="_blank"><i class="fab fa-github-square" aria-hidden="true"></i><span>Github</span></a></li><li><a class="e-social-link" href="https://orcid.org/0000-0001-5559-2259" target="_blank"><i class="fab fa-orcid" aria-hidden="true"></i><span>ORCID</span></a></li><li><a class="e-social-link" href="mailto:[junyl@zju.edu.cn]" target="_blank"><i class="fas fa-envelope" aria-hidden="true"></i><span>E-mail</span></a></li><li><a class="e-social-link" href="javascript:void(0);" onclick="document.getElementById('wechatModal').style.display='block'"><i class="fab fa-weixin" aria-hidden="true"></i><span>WeChat</span></a><div class="modal" id="wechatModal"><div class="modal-content"></div><span class="close">&times;</span><img src="/img/wechatqrcode.jpg" alt="WeChat QR Code" style="width:100%"></div></li><li><a class="e-social-link" href="https://www.zhihu.com/people/lang-ji-lin-64" target="_blank"><i class="fab fa-zhihu" aria-hidden="true"></i><span>知乎主页</span></a></li></ul></div></div></div><div class="page" itemscope itemtype="http://schema.org/CreativeWork"><h2 class="page-title">代码随想录算法训练营第十五天 | 110. 平衡二叉树、257. 二叉树的所有路径、404. 左叶子之和、222. 完全二叉树的节点个数</h2><article><hr>
<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a>110. 平衡二叉树</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html">click here</a></p>
</li>
<li><p>题目描述：给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
</li>
<li><p>思路：<br>  其实就是遍历求每个节点的高度，顺带判断它的左右子树的高度相差是否超过1</p>
<p>  但是高度不重要，重要的是是否平衡，只有一个地方不平衡，就可以开始归的过程</p>
</li>
<li><p>后序递归法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">(TreeNode *cur, <span class="type">bool</span> &amp;balance)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> height1 = <span class="built_in">getheight</span>(cur-&gt;left, balance);</span><br><span class="line">        <span class="keyword">if</span> (!balance)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> height2 = <span class="built_in">getheight</span>(cur-&gt;right, balance);</span><br><span class="line">        <span class="keyword">if</span> (!balance)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(height1 - height2) &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            balance = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(height1, height2) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> _ = <span class="built_in">getheight</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/description/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html">click here</a></p>
</li>
<li><p>题目描述：给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p>
<p>  叶子节点 是指没有子节点的节点。使用迭代法完成二叉树的前中后序遍历</p>
</li>
<li><p>思路：<br>  我的想法：递归获取左右子树的路径，然后再加上当前节点，汇总路径，返回上一层</p>
</li>
<li><p>递归代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">        string cur = std::<span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">        vector&lt;string&gt; left = <span class="built_in">binaryTreePaths</span>(root-&gt;left);      <span class="comment">// 获取左子树路径</span></span><br><span class="line">        vector&lt;string&gt; right = <span class="built_in">binaryTreePaths</span>(root-&gt;right);    <span class="comment">// 获取右子树路径</span></span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 汇总路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> path : left)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp_string = cur;</span><br><span class="line">            temp_string = temp_string + <span class="string">&quot;-&gt;&quot;</span> + path;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp_string);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> path : right)</span><br><span class="line">        &#123;</span><br><span class="line">            string temp_string = cur;</span><br><span class="line">            temp_string = temp_string + <span class="string">&quot;-&gt;&quot;</span> + path;</span><br><span class="line">            res.<span class="built_in">push_back</span>(temp_string);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树路径都为空，则该节点为叶子节点，路径中不带 -&gt; 符号</span></span><br><span class="line">        <span class="keyword">if</span> (left.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; right.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>讲解思路：<br>  递归+回溯，先向下找最深的路，然后返回一级，尝试另一条路，相当于每个节点有左右两条可以走，走到底了要返回来走另一条路。</p>
<p>  结果 是 沿路收集的，直到走到底。</p>
<p>  我的方法是从底向上收集。</p>
<p>  回溯写法，需要注意，递进去，归的时候要还原路径。</p>
<p>  递归函数传参：当前节点、当前已收集路径、汇总结果</p>
<p>  递归终止条件：走到底了，将已收集的路径汇总到结果里</p>
<p>  递归内部逻辑：用当前值，更新路径，然后尝试往左边收集，收集完回退，<br>          再用当前值，更新路径，然后尝试往右边收集，收集完回退</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;string&gt; &amp;result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 走到底了，回收</span></span><br><span class="line">        <span class="keyword">if</span> (!(cur-&gt;left) &amp;&amp; !(cur-&gt;right))</span><br><span class="line">        &#123;</span><br><span class="line">            string res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : path)</span><br><span class="line">            &#123;</span><br><span class="line">                res += (std::<span class="built_in">to_string</span>(num) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res += std::<span class="built_in">to_string</span>(cur-&gt;val);</span><br><span class="line">            result.<span class="built_in">push_back</span>(res);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试往左走</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回到岔路口</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试往右走</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回到岔路口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;string&gt;();</span><br><span class="line">        <span class="built_in">traversal</span>(root, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a>404. 左叶子之和</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/description/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html">click here</a></p>
</li>
<li><p>题目描述：给定二叉树的根节点 root ，返回所有左叶子之和。</p>
</li>
<li><p>思路：<br>  我的想法：前序遍历，给递归函数加一个标志位参数，表示当前这个节点是不是其父节点的左孩子节点。</p>
<p>  如果左孩子节点是叶子，即为左叶子，则将数值累加。</p>
</li>
<li><p>迭代代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur, <span class="type">int</span> &amp;sum, <span class="type">bool</span> left)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(cur-&gt;left) &amp;&amp; !(cur-&gt;right))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (left)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += cur-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;left, sum, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">traversal</span>(cur-&gt;right, sum, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root, sum, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>讲解思路：<br>  抽象的定义递归函数的意义，就是求左子树的左叶子之和，再求右子树的左叶子之和，加起来就是整棵树的左叶子之和。<br>  这其实就回答了“递归内部的逻辑”<br>  不过还漏了一点，就是如果左子树就是一个左叶子，那么其值不必递归计算。真正赋值的地方也就是这里，而非下述递归终止的地方，因为那个地方只能知道自己是空或自己是叶子，往下无需再找，故而返回0。<br>  而它无法知道自己是不是父节点的左孩子。<br>  所以这个判断逻辑一定是在父节点中去做，也就是在“递归内部的逻辑”里实现</p>
<p>  递归的传参及返回值：传入当前节点，返回当前节点的左叶子总和</p>
<p>  递归终止：当前节点为空，返回0，当前节点没有左右子节点了，返回0</p>
</li>
<li><p>讲解代码：后序递归遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right== <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="comment">// 左，是一棵树</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; <span class="comment">// 左子树就是一个左叶子的情况</span></span><br><span class="line">            leftValue = root-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="comment">// 右，是一棵树</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = leftValue + rightValue;               <span class="comment">// 中，汇总左右的结果</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a>222. 完全二叉树的节点个数</h2><ul>
<li><p>题目链接：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/description/">click here</a></p>
</li>
<li><p>文章讲解：<a target="_blank" rel="noopener" href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html">click here</a></p>
</li>
<li><p>题目描述：给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
</li>
<li><p>思路：<br>  简单的做法就是遍历，然后累加个数</p>
</li>
<li><p>简单方法 代码：适用于非完全二叉树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代，层序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode *&gt; qt;</span><br><span class="line">        <span class="keyword">if</span> (root)</span><br><span class="line">            qt.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!qt.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> top = qt.<span class="built_in">front</span>();</span><br><span class="line">            qt.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            sum++;</span><br><span class="line">            <span class="keyword">if</span> (top-&gt;left)</span><br><span class="line">                qt.<span class="built_in">push</span>(top-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (top-&gt;right)</span><br><span class="line">                qt.<span class="built_in">push</span>(top-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归：后序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traserval</span><span class="params">(TreeNode *cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left_num = <span class="built_in">traserval</span>(cur-&gt;left);</span><br><span class="line">        <span class="type">int</span> right_num = <span class="built_in">traserval</span>(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left_num + right_num + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traserval</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>讲解思路：</p>
<ol>
<li>利用好完全二叉树的性质：完全二叉树总能划分为几颗满二叉树</li>
<li>满二叉树也是完全二叉树，同时它更加特殊，满二叉树向左遍历和向右遍历的深度一致</li>
</ol>
<p>  于是可以加快上述递归，即，无需递归到叶子节点，只需要抵达某颗满二叉树的根节点，即可无需向下递归了，因为判断它是根节点的时候已经获取了它的深度，那么直接根据公式 节点数 &#x3D; 2^depth - 1 即可提前结束递归。</p>
<p>  也就是说递归的终止条件从原来的：当前节点为空，返回0<br>  变为：当前节点为空，返回0 + 判断当前节点往下是否是满二叉树，若是，则返回 2^depth - 1</p>
</li>
<li><p>最终代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traserval</span><span class="params">(TreeNode *cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cur)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode *left = cur-&gt;left;</span><br><span class="line">        TreeNode *right = cur-&gt;right;</span><br><span class="line">        <span class="type">int</span> deep_left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> deep_right = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left)</span><br><span class="line">        &#123;</span><br><span class="line">            deep_left++;</span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right)</span><br><span class="line">        &#123;</span><br><span class="line">            deep_right++;</span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (deep_left == deep_right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; deep_left) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left_num = <span class="built_in">traserval</span>(cur-&gt;left);</span><br><span class="line">        <span class="type">int</span> right_num = <span class="built_in">traserval</span>(cur-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left_num + right_num + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traserval</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="今日收获"><a href="#今日收获" class="headerlink" title="今日收获"></a>今日收获</h2><ul>
<li><p>个人博客更新。若Blog有误或是有其他想交流的，左侧有联系方式。</p>
</li>
<li><p>复习：</p>
<p>  <strong>今日核心思想：</strong></p>
<ol>
<li>二叉树的遍历以完成各种任务，比如判断树是否平衡、统计左叶子之和、计算完全二叉树的节点个数</li>
<li>回溯初步：注意回溯和递归，递进去前修改了什么，归回来后就要返还什么。</li>
</ol>
<p>  <strong>平衡二叉树：</strong><br>      遍历统计高度，并附带判断左右子树高度是否偏差大于1</p>
<p>  <strong>二叉树的所有路径：</strong><br>      回溯法：不断累计结果，直到叶子处统计一轮结果，再回溯到上游分岔口，向另一个方向探索。</p>
<p>  <strong>左叶子之和：</strong><br>      递归：计算左子树的左叶子和，右子树的左叶子和，加起来就是整棵树的左叶子和，递归终止条件是当前节点没有叶子可探索了。左叶子和的计算则需要体现在父节点中，也就是“递归内部逻辑里”，由父节点判断左子树是否本质上是左叶子，是则累计结果。</p>
<p>  <strong>完全二叉树的节点个数：</strong><br>      递归：利用完全二叉树可划分为数个满二叉树，而满二叉树极端向左向右遍历的最终深度一致的性质，快捷获取整棵满二叉树的内部节点个数，而无需老老实实递归到所有的叶子节点。</p>
<p>  细节是：</p>
<ol>
<li>2^depth - 1的公式适用于将根节点记为深度1，</li>
<li>而具体的代码计算则需要使用 &lt;&lt; 右移运算符，对 1 &lt;&lt; n 次就得到 2^n 次方，</li>
<li>形象的理解就是 &lt;&lt; 等价于 指数加法，所以 1 &lt;&lt; n &lt;&lt;&#x3D;&#x3D;&gt;&gt; 2^(0+n)</li>
</ol>
</li>
<li><p>耗时：2h</p>
</li>
</ul>
<hr>
<ul>
<li><a href="../../Blogs/day_14">上一篇：代码随想录算法训练营第十四天 | 226. 翻转二叉树、101. 对称二叉树、104. 二叉树的最大深度、111. 二叉树的最小深度</a></li>
<li><a href="../../Blogs">下一篇：(TBA)</a></li>
</ul>
</article></div></main><div class="nav-wrap"><div class="nav"><button class="site-nav"><div class="navicon"></div></button><ul class="nav_items"><li class="nav_item"><a class="nav-page" href="/"> About</a></li><li class="nav_item"><a class="nav-page" href="/Publications/"> Publications</a></li><li class="nav_item"><a class="nav-page" href="/Projects/"> Projects</a></li><li class="nav_item"><a class="nav-page" href="/Blogs/"> Blogs</a></li></ul></div><div class="cd-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></div></div><footer id="page_footer"><div class="footer_wrap"><div class="copyright">&copy;2024 by Junyuan Lu(陆俊元)</div><div class="theme-info">Powered by <a target="_blank" href="https://hexo.io" rel="nofollow noopener">Hexo</a> & <a target="_blank" href="https://github.com/PhosphorW/hexo-theme-academia" rel="nofollow noopener">Academia Theme</a></div><!-- 不蒜子统计--><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span></span><span class="post-meta-divider">|</span><span id="busuanzi_container_site_uv" style="display:none">本站访客数<span id="busuanzi_value_site_uv"></span></span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-pjax@latest/jquery.pjax.min.js"></script><script src="/js/main.js"></script><script src="//clustrmaps.com/map_v2.js?d=gO9Ee5geOQJr4A8o_oWFrvEhrFzUuwpnDv6pPrVbx8U&amp;cl=ffffff&amp;w=a"></script></body></html>